[
  {
    "objectID": "Homework6_Costello.html",
    "href": "Homework6_Costello.html",
    "title": "Homework 6",
    "section": "",
    "text": "What is the purpose of lapply() function? What is the equivalent purrr function? lapply applies a function to a list. The equivalent purrr function is map().\nSuppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want use lapply() to run the code cor(numeric_matrix, method = \"kendall\") on each element of the list. Write code to do this below! (I’m really trying to ask you how you specify method = \"kendall\" when calling lapply()).\nlapply(X = my_list, MARGIN = 2, FUN = cor, method = \"kendall\")\nWhat are two advantages of using purrr functions instead of the BaseR apply family? More consistency and helper functions!\nWhat is a side-effect function? A function that does not change the data, but produces something. Examples are print(), write_csv(), and plot().\nWhy can you name a variable sd in a function and not cause any issues with the sd function? This is due to lexical scoping. When you call a function, it creates a temporary function environment. It remains in that environment and doesn’t override the sd function. If R doesn’t find the object in the current environment, then it will search up the path and can still access the sd function."
  },
  {
    "objectID": "Homework6_Costello.html#task-1-conceptual-questions",
    "href": "Homework6_Costello.html#task-1-conceptual-questions",
    "title": "Homework 6",
    "section": "",
    "text": "What is the purpose of lapply() function? What is the equivalent purrr function? lapply applies a function to a list. The equivalent purrr function is map().\nSuppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want use lapply() to run the code cor(numeric_matrix, method = \"kendall\") on each element of the list. Write code to do this below! (I’m really trying to ask you how you specify method = \"kendall\" when calling lapply()).\nlapply(X = my_list, MARGIN = 2, FUN = cor, method = \"kendall\")\nWhat are two advantages of using purrr functions instead of the BaseR apply family? More consistency and helper functions!\nWhat is a side-effect function? A function that does not change the data, but produces something. Examples are print(), write_csv(), and plot().\nWhy can you name a variable sd in a function and not cause any issues with the sd function? This is due to lexical scoping. When you call a function, it creates a temporary function environment. It remains in that environment and doesn’t override the sd function. If R doesn’t find the object in the current environment, then it will search up the path and can still access the sd function."
  },
  {
    "objectID": "Homework6_Costello.html#task-2-writing-r-functions",
    "href": "Homework6_Costello.html#task-2-writing-r-functions",
    "title": "Homework 6",
    "section": "Task 2: Writing R Functions",
    "text": "Task 2: Writing R Functions\n\nWrite a basic function that takes in a vector of responses and a vector of predictions and outputs the RMSE. RMSE is the square root of the average of squared errors.\n\n\nlibrary(purrr)\n\ngetRMSE &lt;- function(resp_vec, pred_vec, ...){\n  squared_error &lt;- map2(resp_vec, pred_vec, \\(x,y) (x-y)^2)\n  squared_mean &lt;- mean(unlist(squared_error),...)\n  square_root &lt;- sqrt(squared_mean)\n  return(square_root)\n}\n\n\nRun the code to create some response values and predictions.\n\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\nTest Function:\n\ngetRMSE(resp, pred)\n\n[1] 0.9581677\n\n\nManually replace two of the response values with missing values (NA_real_) (just assign two values to NA_real_).\n\nresp[1] &lt;- NA_real_\nresp[2] &lt;- NA_real_\n\nTest the RMSE function without and with specifying the behavior to deal with missing values.\n\n#without\ngetRMSE(resp, pred)\n\n[1] NA\n\n\n\n#with\ngetRMSE(resp, pred, na.rm = TRUE)\n\n[1] 0.9661699\n\n\n\nWrite a basic function that takes in a vector of responses and a vector of predictions and outputs the Mean Absolute Deviation.\n\n\ngetMAE &lt;- function(resp_vec, pred_vec, ...){\n  abs_diffs &lt;- map2(resp_vec, pred_vec, \\(x,y) abs(x-y))\n  mean_diffs &lt;- mean(unlist(abs_diffs),...)\n  return(mean_diffs)\n}\n\n\nRun the the following code to create some response values and predictions.\n\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\nTest getMAE() function.\n\ngetMAE(resp, pred)\n\n[1] 0.8155776\n\n\nReplace two of the response values with missing values.\n\nresp[4] &lt;- NA_real_\nresp[5] &lt;- NA_real_\n\nTest the MAE function without and with specifying the behavior to deal with missing values.\n\n#without\ngetMAE(resp, pred)\n\n[1] NA\n\n\n\n#with\ngetRMSE(resp, pred, na.rm = TRUE)\n\n[1] 0.9448805\n\n\n\nCreate a wrapper function that can be used to get either or both metrics returned with a single function call.\n\n\nMAE_RMSE_wrapper &lt;- function(resp_vec, pred_vec, return_MAE = TRUE, return_RMSE = TRUE, ...){\n  if (!is.vector(resp_vec)) {stop(\"Responses are not a vector!\")}\n  if (!is.vector(pred_vec)) {stop(\"Predictions are not a vector!\")}\n  if (!is.numeric(resp_vec)) {stop(\"Responses are not numeric!\")}\n  if (!is.numeric(pred_vec)) {stop(\"Predictions are not numeric!\")}\n  \n  results &lt;- list()\n  \n  if(return_MAE) {\n    results$MAE_result &lt;- getMAE(resp_vec, pred_vec,...)\n  }\n  if(return_RMSE) {\n    results$RMSE_result &lt;- getRMSE(resp_vec, pred_vec,...)\n  }\n  return(results)\n}\n\n\nRun the following code to create some response values and predictions.\n\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\nTest function. Call it once asking for each metric individually and once specifying both metrics.\n\n#Return both metrics\nMAE_RMSE_wrapper(resp, pred)\n\n$MAE_result\n[1] 0.8155776\n\n$RMSE_result\n[1] 0.9581677\n\n\n\n#Return only RMSE\nMAE_RMSE_wrapper(resp, pred, return_MAE = FALSE)\n\n$RMSE_result\n[1] 0.9581677\n\n\n\n#Return only MAE\nMAE_RMSE_wrapper(resp, pred, return_RMSE = FALSE)\n\n$MAE_result\n[1] 0.8155776\n\n\nRepeat with replacing two of the response values with missing values.\n\nresp[2] &lt;- NA_real_\nresp[3] &lt;- NA_real_\n\n\nMAE_RMSE_wrapper(resp, pred, na.rm = TRUE)\n\n$MAE_result\n[1] 0.815386\n\n$RMSE_result\n[1] 0.9579819\n\nMAE_RMSE_wrapper(resp, pred, return_MAE = FALSE, na.rm = TRUE)\n\n$RMSE_result\n[1] 0.9579819\n\nMAE_RMSE_wrapper(resp, pred, return_RMSE = FALSE, na.rm = TRUE)\n\n$MAE_result\n[1] 0.815386\n\n\nTest function by passing it incorrect data (not a vector).\n\nlibrary(Lahman)\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.2\n✔ ggplot2   4.0.0     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nmy_batting &lt;- Batting[, c(\"playerID\", \"teamID\", \"G\", \"AB\", \"R\", \"H\", \"X2B\", \"X3B\", \"HR\")] |&gt;\n  as_tibble()\nmy_batting\n\n# A tibble: 115,450 × 9\n   playerID  teamID     G    AB     R     H   X2B   X3B    HR\n   &lt;chr&gt;     &lt;fct&gt;  &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;\n 1 aardsda01 SFN       11     0     0     0     0     0     0\n 2 aardsda01 CHN       45     2     0     0     0     0     0\n 3 aardsda01 CHA       25     0     0     0     0     0     0\n 4 aardsda01 BOS       47     1     0     0     0     0     0\n 5 aardsda01 SEA       73     0     0     0     0     0     0\n 6 aardsda01 SEA       53     0     0     0     0     0     0\n 7 aardsda01 NYA        1     0     0     0     0     0     0\n 8 aardsda01 NYN       43     0     0     0     0     0     0\n 9 aardsda01 ATL       33     1     0     0     0     0     0\n10 aaronha01 ML1      122   468    58   131    27     6    13\n# ℹ 115,440 more rows\n\nchar_vec &lt;- c(\"Hi\", \"Hello\", \"Bonjour\", \"Hola\")\n\n\nMAE_RMSE_wrapper(my_batting, pred, na.rm = TRUE)\n\nError in MAE_RMSE_wrapper(my_batting, pred, na.rm = TRUE): Responses are not a vector!\n\n\n\nMAE_RMSE_wrapper(resp, char_vec, na.rm = TRUE)\n\nError in MAE_RMSE_wrapper(resp, char_vec, na.rm = TRUE): Predictions are not numeric!"
  },
  {
    "objectID": "Homework6_Costello.html#task-3-practice-with-purrr",
    "href": "Homework6_Costello.html#task-3-practice-with-purrr",
    "title": "Homework 6",
    "section": "Task 3: Practice with purrr",
    "text": "Task 3: Practice with purrr\nSet up:\n\nlibrary(purrr)\n\nLet’s create a list object.\n\nlm_fit1 &lt;- lm(Sepal.Length ~ Sepal.Width + Species, data = iris)\n\n\nPull out the coefficients list element using $, coef(), and the pluck() function from purrr.\n\n\nlm_fit1$coefficients\n\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\n\n\ncoef(lm_fit1) \n\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\n\n\nlm_fit1 |&gt;\n  pluck(coefficients)\n\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\n\n\nLet’s fit a number of different models with the code below.\n\n\nlm_fit2 &lt;- lm(Sepal.Length ~ Sepal.Width, data = iris)\nlm_fit3 &lt;- lm(Sepal.Length ~ Petal.Width + Sepal.Width + Species, data = iris)\nlm_fit4 &lt;- lm(Sepal.Length ~ Petal.Width + Petal.Length + Sepal.Width + Species,\n              data = iris)\nfits &lt;- list(lm_fit1, lm_fit2, lm_fit3, lm_fit4)\n\nUse the map() function to pull out the coefficients of each model fit from the fits object, using pluck().\n\nmap(fits, \n    \\(x) pluck(x, \"coefficients\"))\n\n[[1]]\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\n[[2]]\n(Intercept) Sepal.Width \n  6.5262226  -0.2233611 \n\n[[3]]\n      (Intercept)       Petal.Width       Sepal.Width Speciesversicolor \n        2.5210733         0.3715768         0.6982260         0.9881297 \n Speciesvirginica \n        1.2375878 \n\n[[4]]\n      (Intercept)       Petal.Width      Petal.Length       Sepal.Width \n        2.1712663        -0.3151552         0.8292439         0.4958889 \nSpeciesversicolor  Speciesvirginica \n       -0.7235620        -1.0234978 \n\n\n\nUse map() to apply the confint() function to each model fit in the fits object.\n\n\nmap(fits, confint)\n\n[[1]]\n                      2.5 %   97.5 %\n(Intercept)       1.5206309 2.982156\nSepal.Width       0.5933983 1.013723\nSpeciesversicolor 1.2371791 1.680307\nSpeciesvirginica  1.7491525 2.144481\n\n[[2]]\n                2.5 %     97.5 %\n(Intercept)  5.579865 7.47258038\nSepal.Width -0.529820 0.08309785\n\n[[3]]\n                        2.5 %    97.5 %\n(Intercept)        1.74261803 3.2995285\nPetal.Width       -0.02042746 0.7635811\nSepal.Width        0.46205710 0.9343950\nSpeciesversicolor  0.44520784 1.5310516\nSpeciesvirginica   0.46412393 2.0110518\n\n[[4]]\n                       2.5 %      97.5 %\n(Intercept)        1.6182321  2.72430044\nPetal.Width       -0.6140049 -0.01630542\nPetal.Length       0.6937939  0.96469395\nSepal.Width        0.3257653  0.66601260\nSpeciesversicolor -1.1982739 -0.24885002\nSpeciesvirginica  -1.6831329 -0.36386273\n\n\n\nNow, let’s create histograms of the residuals in each model fit!\n\n\npar(mfrow = c(2, 2))  #set up plotting window\nfits |&gt;\n  map(\\(x) pluck(x, \"residuals\")) |&gt;\n  walk(hist)\n\n\n\n\n\n\n\n\n\nUse set_names() function to give names to the list elements.\n\n\nresid &lt;- map(fits, \n             \\(x) pluck(x, \"residuals\")) |&gt;\n  set_names(c(\"fit1\", \"fit2\", \"fit3\", \"fit4\"))\n\nAttempt at using iwalk.\n\npar(mfrow = c(2, 2))\niwalk(resid, names(resid), \\(x) hist(x))"
  }
]