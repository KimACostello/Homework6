---
title: "Homework 6"
author: "Kim Costello"
format: html
editor: visual
---

## Task 1: Conceptual Questions

1.  **What is the purpose of `lapply()` function? What is the equivalent `purrr` function?** `lapply` applies a function to a list. The equivalent `purrr` function is `map()`.

2.  **Suppose we have a list called `my_list`. Each element of the list is a numeric data frame (all columns are numeric). We want use `lapply()` to run the code `cor(numeric_matrix, method = "kendall")` on each element of the list. Write code to do this below! (Iâ€™m really trying to ask you how you specify `method = "kendall"` when calling `lapply()`).**\
    `lapply(X = my_list, MARGIN = 2, FUN = cor, method = "kendall")`

3.  **What are two advantages of using `purrr` functions instead of the BaseR apply family?** More consistency and helper functions!

4.  **What is a side-effect function?** A function that does not change the data, but produces something. Examples are print(), write_csv(), and plot().

5.  **Why can you name a variable `sd` in a function and not cause any issues with the `sd` function?** This is due to lexical scoping. When you call a function, it creates a temporary function environment. It remains in that environment and doesn't override the sd function. If R doesn't find the object in the current environment, then it will search up the path and can still access the sd function.


## Task 2: Writing R Functions

1.  Write a basic function that takes in a vector of responses and a vector of predictions
and outputs the RMSE. RMSE is the square root of the average of squared errors.
```{r}
library(purrr)

getRMSE <- function(resp_vec, pred_vec, ...){
  squared_error <- map2(resp_vec, pred_vec, \(x,y) (x-y)^2)
  squared_mean <- mean(unlist(squared_error),...)
  square_root <- sqrt(squared_mean)
  return(square_root)
}
```

2.  Run the code to create some response values and predictions.
```{r}
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10 * x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))
```
Test Function: 
```{r}
getRMSE(resp, pred)
```
Manually replace two of the response values with missing values (NA_real_) (just assign
two values to NA_real_). 
```{r}
resp[1] <- NA_real_
resp[2] <- NA_real_
```

Test the RMSE function without and with specifying the behavior to deal with missing values. 
```{r}
#without
getRMSE(resp, pred)
```
```{r}
#with
getRMSE(resp, pred, na.rm = TRUE)
```
3.  Write a basic function that takes in a vector of responses and a vector of predictions
and outputs the Mean Absolute Deviation. 
```{r}
getMAE <- function(resp_vec, pred_vec, ...){
  abs_diffs <- map2(resp_vec, pred_vec, \(x,y) abs(x-y))
  mean_diffs <- mean(unlist(abs_diffs),...)
  return(mean_diffs)
}
```

4.  Run the the following code to create some response values and predictions. 
```{r}
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10 * x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))
```
Test `getMAE()` function. 
```{r}
getMAE(resp, pred)
```
Replace two of the response values with missing values. 
```{r}
resp[4] <- NA_real_
resp[5] <- NA_real_
```
Test the MAE function without and with specifying the behavior to deal with missing values.
```{r}
#without
getMAE(resp, pred)
```
```{r}
#with
getRMSE(resp, pred, na.rm = TRUE)
```
5.  Create a wrapper function that can be used to get either or both metrics returned with a single function call. 
```{r}
MAE_RMSE_wrapper <- function(resp_vec, pred_vec, return_MAE = TRUE, return_RMSE = TRUE, ...){
  if (!is.vector(resp_vec)) {stop("Responses are not a vector!")}
  if (!is.vector(pred_vec)) {stop("Predictions are not a vector!")}
  if (!is.numeric(resp_vec)) {stop("Responses are not numeric!")}
  if (!is.numeric(pred_vec)) {stop("Predictions are not numeric!")}
  
  results <- list()
  
  if(return_MAE) {
    results$MAE_result <- getMAE(resp_vec, pred_vec,...)
  }
  if(return_RMSE) {
    results$RMSE_result <- getRMSE(resp_vec, pred_vec,...)
  }
  return(results)
}

```
6.  Run the following code to create some response values and predictions. 
```{r}
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10 * x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))
```

Test function. Call it once asking for each metric individually and once specifying both metrics. 
```{r}
#Return both metrics
MAE_RMSE_wrapper(resp, pred)
```
```{r}
#Return only RMSE
MAE_RMSE_wrapper(resp, pred, return_MAE = FALSE)
```
```{r}
#Return only MAE
MAE_RMSE_wrapper(resp, pred, return_RMSE = FALSE)
```
Repeat with replacing two of the response values with missing values. 
```{r}
resp[2] <- NA_real_
resp[3] <- NA_real_
```

```{r}
MAE_RMSE_wrapper(resp, pred, na.rm = TRUE)
MAE_RMSE_wrapper(resp, pred, return_MAE = FALSE, na.rm = TRUE)
MAE_RMSE_wrapper(resp, pred, return_RMSE = FALSE, na.rm = TRUE)
```
Test function by passing it incorrect data (not a vector). 
```{r}
library(Lahman)
library(tidyverse)

my_batting <- Batting[, c("playerID", "teamID", "G", "AB", "R", "H", "X2B", "X3B", "HR")] |>
  as_tibble()
my_batting

char_vec <- c("Hi", "Hello", "Bonjour", "Hola")
```

```{r}
#| error: TRUE
MAE_RMSE_wrapper(my_batting, pred, na.rm = TRUE)
```
```{r}
#| error: TRUE
MAE_RMSE_wrapper(resp, char_vec, na.rm = TRUE)
```


## Task 3: Practice with purrr

Set up: 
```{r}
library(purrr)
```


Let's create a list object. 
```{r}
lm_fit1 <- lm(Sepal.Length ~ Sepal.Width + Species, data = iris)
```

1.  Pull out the `coefficients` list element using $, `coef()`, and the `pluck()` function from `purrr`.
```{r}
lm_fit1$coefficients
```
```{r}
coef(lm_fit1) 
```

```{r}
lm_fit1 |>
  pluck(coefficients)
```
2.  Let's fit a number of different models with the code below. 
```{r}
lm_fit2 <- lm(Sepal.Length ~ Sepal.Width, data = iris)
lm_fit3 <- lm(Sepal.Length ~ Petal.Width + Sepal.Width + Species, data = iris)
lm_fit4 <- lm(Sepal.Length ~ Petal.Width + Petal.Length + Sepal.Width + Species,
              data = iris)
fits <- list(lm_fit1, lm_fit2, lm_fit3, lm_fit4)
```

Use the `map()` function to pull out the coefficients of each model fit from the `fits` object, using `pluck()`. 
```{r}
map(fits, 
    \(x) pluck(x, "coefficients"))
```

3.  Use `map()` to apply the `confint()` function to each model fit in the `fits` object.
```{r}
map(fits, confint)
```

4.  Now, let's create histograms of the residuals in each model fit! 

```{r}
par(mfrow = c(2, 2))  #set up plotting window
fits |>
  map(\(x) pluck(x, "residuals")) |>
  walk(hist)
  
```
5.  Use `set_names()` function to give names to the list elements.
```{r}
resid <- map(fits, 
             \(x) pluck(x, "residuals")) |>
  set_names(c("fit1", "fit2", "fit3", "fit4"))
```

Attempt at using `iwalk`.
```{r}
par(mfrow = c(2, 2))
iwalk(resid, names(resid), \(x) hist(x))
```

